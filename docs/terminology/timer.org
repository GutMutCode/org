#+title: Timer

* Timer (in microcontroller)
** Output Compare
A feature of timers/counters used to generate *precise time-based events*.

It compares the value in the timer/counter with a pre-set value, and when they match, it triggers specific actions, such as toggling a pin, generating an interrupt, or resetting the timer.

*** How It Works
1. Timer Counting
   A timer increments or decrements continuously, based on the clock frequncy.

2. Output Compare Register (OCR)
   You set a specific value in the OCR. When the timer reaches this value, it triggers an event.

3. Compare Match Event
   On match, an *action* can be taken, such as:
   - Toggle, set, or clear an output pin
   - Generate an *interrupt*
   - Start or stop another process

** Input Capture
A feature used to measure the timing(timestamp) of external events accurately.

Capturing the value of a *timer/counter* when a specific input signal changed state, like going from low to high(rising edge) or vice versa(falling edge)

*** Features
**** Measuring the frequency of signal
**** Measuring pulse widths
For example, in PWM signals.
**** Time-stamping events
e.g., measuring time between two triggers.

*** How It Works?
1. A timer in the microcontroller runs continuously, counting up at a specified frequency.
2. When the input signal connected to an input capture pin changes state (edge-triggered), the current value of the timer is copied (or "captured") into a capture register
3. An interrupt can be generated when this capture event occurs, allowing the processor to handle the event immediately

*** Use Cases
**** Frequency counter (detection)
_To determine the frequency of a signal_, measure the time between two consecutive rising edges

**** Pulse width modlation (PWM) analysis
_To determine the duty cycle_, capture the high and low periods.

**** Event time stamping
Capture the exact time a switch was pressed or a sensor triggered.
** Input Capture Noise Canceler
Improves the reliability of input capture by filtering out spurious noise signals.

*** Problem: Noise on Input Signals
Input signals may be affected by noise, causing unintended or false captures.

For example, electromagnetic interference (EMI) could create brief glitches that trigger the input capture system.

*** How It Works?
Helps eliminate these glitches by passing the input signal through a digital filter.

1. Multiple samples of the input pin are taken at a high rate.
2. THe input capture event is only registered if the same logic level (high or low) is detected consistently over multiple samples (usually over 4 cycles of the internal clock.)
3. This filtering process ensures that short, spurious pulses do not trigger an input capture.

*** Use Cases
- In noisy environments where the signal might be prone to brief spikes.
- Helps ensuer the input capture feature only register legitimate signal changes, improving accuracy in timing measurements.
** Double Buffering
Ensure precise control over the timing of events like [[file:./pwm.org][PWM]] signals or interrupt.

*** How It Works?
**** Buffering Mechanism
- The microcontroller has *two sets of registers* for the same timer functionality.
  - *Temporary (Buffer) Register*: Used to load a new value
  - *Active (Output Compare) Register*: Used during real-time operation
- When an update is needed, the value is first written to the *buffer* register.
  The active register gets updated only at a well-defined time, such as the next *timer overflow or compare event*.

**** Purpose of Double Buffering
- *Glitch-Free Operation*
  Prevents incorrect or partial updates to the register during ongoing timer operations.

- *Synchronization with Timer Events*
  Ensures that the output compare value is updated only at the right moment (e.g., at the end of the current timer period, Not before).

- *Avoid Race Conditions*
  Ensures that an update doesn't conflict with the timer counting or interrupt routines

**** Use Cases (Where It's used)
- *PWM generation*
  Smoothly update the duty cycle without introducing glitches.

- *Periodic interrupts*
  Ensure the timing of interrupts remains accurate even when updating compare values.
*** Example Scenario
Consider a PWM signal generated by a microcontroller's timer to control an LED's brightness.
If you want to change the duty cycle, writing directly to the active output compare register could cause unpredictable behavior if the change happens mid-cycle.
Double buffering allows the new duty cycle value to take effect *only at the beginning of the next PWM cycle*, ensuring smooth transitions.

** Modes of Operation
The behavior of the Timer/Counter and the Output Compare pins, is defined by the combination of the /Waveform Generation mode (~WGMn3:0~)/ and /Compare Output Mode (~COMnx1:0~)/ bits.

*** Waveform Generation Mode
affect the counting sequence

**** Normal mode (WGMn3:0 = 0)
- The counting direction is always up (incrementing)
- no counter clear is performed.
- The counter simply overruns when it passes its maximum 16-bit value (0xFFFF) and then restarts from the BOTTOM (0x0000)
- The Timer/Counter Overflow Flag (~TOVn~) will be set in the same timer clock cycle as the ~TCNTn~ becomes zero.
- The ~TOVn~ Flag in this case behaves like a 17th bit, except that it is only set, not cleared.
- To increase the timer resolution by software, you can use the timer overflow interrupt that automatically clears the ~TOVn~ Flag.
- There are no special cases to consider in the Normal mode, a new counter value can be written anytime.

***** Input Capture
Easy to use in Normal mode.

The maximum interval between the external events must not exceed the resolution of the counter.
- if the interval between events are too long, the timer overflow interrupt or the prescaler must be used to extend the resolution for the capture unit.

***** Output Compare
It can be used to generate interrupts at some given time.

Using the Output Comare to generate waveform in Normal mode is not recommended, since this will occupy too much of the CPU time.
**** Clear Timer on Compare Match (CTC) mode (WGMn3:0 = 4 or 12)
In Clear Timer on Compare or CTC mode, the ~OCRnA~ or ~ICRn~ Register are used to manipulate the counter resolution.

- The counter is cleared to zero when the counter value (~TCNTn~) matches either the ~OCRnA~ (WGMn3:0 = 4) or ~ICRn~ (WGMn3:0 = 12).
- The ~OCRnA~ or ~ICRn~ define the top value for the counter, hence also its resolution.
- This mode allows greater control of the compare match output frequency.
- It also simplifies the operation of counting external events.

***** Changing the TOP while the counter is running
Changing the TOP to a value close to BOTTOM when the counter is running with none or a low prescaler value must be done with care in CTC mode

- Since the CTC mode does not have the double buffering feature.
  The new value takes effect to the active register *IMMEDIATELY*.

- If the new value written to ~OCRnA~ or ~ICRn~ is lower than the current value of ~TCNTn~, the counter _will miss the compare match_.

****** How the Prescaler Affects this Process?
A prescaler divides the system clock frequency to control the speed of the timer counter.

For example:
#+begin_quote
- With no prescaler, the timer imcrements very fast (every clock cycle)
- With a higher prescaler, (e.g., 1024), the timer increments slowly.
#+end_quote

If the prescaler is set *too low or disabled*, the timer counts *very quickly*. This increases the chance that:
#+begin_quote
- The counter reaches its current TOP before you safely change it.
- An incomplete or unexpected cycle occurs because the change takes effect immediately.
#+end_quote
***** Toggle OCnA output (COMnA1:0 = 1)
Toggle its logical level on each compare match.

You should set the data direction register

*** Compare Output Mode
don't affect the counting sequence

Weather the PWM output generated should be inverted or not (inverted or non-inverted PWM)

**** non-PWM
Whether the output should be set, cleared or toggle at a compare match

* Terminology
** Counter Resolution
In the context of a microcontroller, *counter resolution* refers to the smallest measurable change or step that the counter or timer can represent.

It is determiend by the frequency of the clock driving the counter and the configuration of the counter's register width (number of bits).

*** Key Aspects of Counter Resolution
**** Clock Frequency (Tick Rate)
- The resolution improves with a higher clock frequency because the counter increments faster.
- For example, if a timer is driven by a 1 MHz clock, the smallest time step the counter can measure is: `Resolution = 1/1MHz = 1us`

**** Register Width (Bit Length)
- The number of bits in the counter register (e.g., 8-bit, 16-bit, 32-bit) determines how many increments it can store before overflowing.
- A wider register increases the total range but does not directly affect the resolution (the smallest measurable change)

**** Prescaler Setting
주파수 나누기 = 주파수 줄이기 = 해상도 늘리기

- A prescaler divides the clock frequency by a fixed amount, which effectively reduces the counter's resolution but allows it to count over longer periods.
- Example: A prescaler of 8 on a 1 MHz clock makes the counter tick every `1/(1MHz/8) = 8us`

**** Example of Resolution
A 16-bit timer with a 1 MHz input clock has a resolution of 1 microsecond.
If it overflows after *2^16 = 65536* counts, it can measure intervals up to: *65536 x 1us = 65.536ms*

* In AVR (practical)
1. if `tid_op` is fired, set it to `1000` and send sensor state to kiosk

* Practical
