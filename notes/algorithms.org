#+title: Algorithms & Data Structure

* 알고리즘
컴퓨터를 통해 문제를 해결하는 방법

** 문제를 정확히 정의하는 것
** 문제를 효율적으로 해결하는 것

*** 문제를 해결 방법은 여러가지가 있을 수 있다.
가장 자원이 적게드는 방법

**** 자원 종류
시간
에너지
비용

**** 문제해결 방법 효율비교
***** 기본동작 정의
****** 정렬 알고리즘
숫자를 비교하는 것을, 기본 동작으로 정의

***** 기본동작의 수행 횟수 비교
선택 정렬 - O(n^2)
퀵 정렬 - O(n log n)

****** log 사전지식
밑수 e가 생략된 상태

* 데이터 구조
데이터를 메모리에 저장하는 방법

** 데이터가 잘 활용될수 있게, 저장하는 것
*** 데이터 저장하는 방법은 여러가지가 있을 수 있다.
활용 빈도수에 맞는 방법

**** 데이터 추가 횟수 > 데이터 검색 횟수
=시간순으로 정렬된 구조=

***** 데이터 추가 방법
끝에 추가

- 새로운 값을 추가할때, 기존에 저장된 데이터의 위치를 변경할 필요가 없다.

***** 데이터 검색 방법 처음부터 끝까지 찾기 (sequential access, 순차접근)
**** 데이터 검색 횟수 > 데이터 추가 횟수
=값을 기준으로 정렬된 구조=

***** 데이터 추가 방법
1. 추가할 위치 찾기
2. 중간에 추가

****** 새로운 값을 추가할때, 기존에 저장된 데이터의 위치를 변경해 주어야한다.
위치를 변경해야하는 데이터 개수

***** 데이터 검색 방법
값을 기준으로 찾기

**** 데이터 검색횟수 ~= 데이터 추가 횟수
=종류별로 나누어진 구조=

***** 데이터 추가 방법
1. 종류 ~검색~
2-1. 해당 종류 ~끝에 추가~
2-2. 해당 종류 ~중간에 추가~

***** 데이터 검색 방법
1. 종류 ~검색~
2-1. 해당 종류에서 ~처음부터 끝까지 찾기~
2-2. 해당 종류에서 ~값을 기준으로 찾기~

** 종류 & 비교
*** Linked-List
각 데이터가 포인터로 연결되어, 메모리상에 흩어 저장할 수 있는 데이터 구조.

Node의 포인터를 통해 데이터에 접근한다.

**** 최악의 수
***** 데이터 접근 (Read, Update)
첫 노드부터 접근하여, 끝 노드 찾기 (선형탐색)
끝 노드부터 접근하여, 첫 노드 찾기 (선형탐색)

****** 기본동작
데이터 비교

****** 최대 동작 시간
O(n)

***** 데이터 추가, 삭제 (Create, Delete)

첫 노드부터 접근하여, 끝 노드에 추가 or 삭제
끝 노드부터 접근하여, 첫 노드에 추가 or 삭제

****** 기본동작
데이터 비교 & 데이터 복사

****** 최대 동작 시간
- 접근 시간: O(n)
- 복사 시간: O(2), Single List 기준 포인터 2개

*** Array
각 데이터가 메모리상에 일렬로 저장하는 데이터 구조.

Index를 통해 데이터에 접근한다.

데이터 추가, 삭제시, 일렬 구조를 유지하기 위해서 대규모 복사 작업이 일어난다.
- n칸씩 뒤로 밀기, 앞으로 당기기


**** 최악의 수
***** 데이터 접근 (Read, Update)
랜덤 접근 (Index를 통한 직접 접근)

****** 기본 동작
데이터 비교

****** 최대 동작 시간
O(1)

***** 데이터 추가, 삭제 (Create, Delete)
첫 요소(element)에 접근하여, 데이터 추가 or 삭제

****** 기본 동작
데이터 비교 & 데이터 복사

****** 최대 동작 시간
- 접근 시간: O(1)
- 복사 시간: O(n)

*** Stack
각 데이터가 메모리상에 일렬로 저장하는 데이터 구조.

Stack의 맨위 주소를 통해 데이터에 접근한다.

**** 최악의 수
***** 데이터 접근 or 삭제 (pop)
가장 오래된 요소 접근 or 삭제

****** 기본 동작
데이터 비교 & pop

****** 최대 동작 시간
O(n)

***** 데이터 추가 (push)
맨 위에 데이터 추가

****** 기본 동작
데이터 복사(push)

****** 최대 동작 시간
O(1)

*** Queue
각 데이터가 메모리상에 일렬로 저장하는 데이터 구조.

Queue의 맨아래 주소를 통해 데이터에 접근한다.

**** 최악의 수
***** 데이터 접근 or 삭제 (dequeue)
가장 최신 요소 접근 or 삭제

****** 기본 동작
데이터 비교 & dequeue

****** 최대 동작 시간
O(n)

***** 데이터 추가 (enqueue)
맨 위에 데이터 추가

****** 기본 동작
데이터 복사(enqueue)

****** 최대 동작 시간
O(1)
*** Hash Table
순서를 통한 검색이 아닌, 값을 통한 검색을 하기좋은 데이터 구조 (이름 검색)

Hash 함수의 원리를 이용해, key를 사용한 value 검색이 가능한 데이터 구조.

배열에, list의 첫번째 Node가 들어있는 구조. (chaining, 분리연쇄법)

1. Hash 함수의 결과값에, 특정 값(일반적으로 배열의 크기)을 나눈 나머지를 구한다 (modular).
2. 나머지 값을 Index로 이용해 배열에 접근한다.

*** Heap (트리구조)
최소값을 찾기 좋은 데이터 구조

최상위 노드 1개가 있다
각 노드는, 자식노드를 최대 2개까지 가질 수 있다.
자식노드는 부모노드보다 큰 데이터를 가질 수 없다.


**** 동작 방식
***** 데이터 접근
1. 맨 위를 제거
2. 맨 아래, 맨 오른쪽 노드를 최상위로 이동
3. 최상위 노드를 규칙에 따라 이동

***** 데이터 추가
1. 맨 아래, 맨 오른쪽에 새로운 노드추가
2. 추가한 노드를 규칙에 따라 이동

**** 최악의 수
***** 데이터 추가
가장 작은 숫자 추가

****** 기본 동작
데이터 비교

****** 최대 동작 시간
O(log n)


***** 데이터 접근
가장 큰 숫자 접근

****** 기본 동작
데이터 비교

****** 최대 동작 시간
O(n)

*** 이진 탐색 트리
최상위 노드 1개
자식 노드 최대 2개
왼쪽 노드에 작은 값
오른쪽 노드에 큰 값

**** 동작 방식
***** 데이터 접근
1. 특정 값 제거
2 - 1. 왼쪽 자식 노드들의 최대값으로 대체
2 - 2. 오른쪽 자식 노드들의 최소값으로 대체

***** 데이터 추가
1. 최상위 노드와 비교
2. 규칙에 따라 비교할 노드가 없을때까지 이동

**** 최악의 수
***** 데이터 추가
최상위 노드가 최대값이고,
모든 노드가 왼쪽 자식 노드만을 가지고 있을때
최소값 추가하기

최상위 노드가 최소값이고,
모든 노드가 오른쪽 자식 노드만을 가지고 있을때
최대값 추가하기

****** 기본 동작
데이터 비교

****** 최대 동작 시간
O(n)

***** 데이터 접근
최상위 노드가 최대값이고,
모든 노드가 왼쪽 자식 노드만을 가지고 있을때
최소값 구하기

최상위 노드가 최소값이고,
모든 노드가 오른쪽 자식 노드만을 가지고 있을때
최대값 구하기

****** 기본 동작
데이터 비교

****** 최대 동작 시간
O(n)

**** 활용 데이터 구조
***** 균형 이진 탐색 트리
이진 탐색 트리 + 트리 불균형 수정

***** B-tree
이진 탐색 트리 + 자식 노드 최대 m개
